import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { combineLatest } from 'rxjs';
import { ScriptLoaderService } from '../../script-loader/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../script-loader/script-loader.service';

const _c0 = ["*"];
export class DashboardComponent {
    constructor(element, loaderService) {
        this.element = element;
        this.loaderService = loaderService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.createDataTable();
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns) {
            this.createDataTable();
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.dashboard.draw(this.dataTable);
        });
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
    createDataTable() {
        if (this.data == null) {
            return;
        }
        let firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
    }
    getDataAsTable() {
        if (this.columns) {
            return [this.columns, ...this.data];
        }
        else {
            return this.data;
        }
    }
}
DashboardComponent.ɵfac = function DashboardComponent_Factory(t) { return new (t || DashboardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ScriptLoaderService)); };
DashboardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DashboardComponent, selectors: [["dashboard"]], contentQueries: function DashboardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ControlWrapperComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlWrappers = _t);
    } }, hostAttrs: [1, "dashboard"], inputs: { data: "data", columns: "columns" }, outputs: { ready: "ready", error: "error" }, exportAs: ["dashboard"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function DashboardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService }
];
DashboardComponent.propDecorators = {
    data: [{ type: Input }],
    columns: [{ type: Input }],
    ready: [{ type: Output }],
    error: [{ type: Output }],
    controlWrappers: [{ type: ContentChildren, args: [ControlWrapperComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DashboardComponent, [{
        type: Component,
        args: [{
                selector: 'dashboard',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'dashboard',
                host: { class: 'dashboard' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.ScriptLoaderService }]; }, { ready: [{
            type: Output
        }], error: [{
            type: Output
        }], data: [{
            type: Input
        }], columns: [{
            type: Input
        }], controlWrappers: [{
            type: ContentChildren,
            args: [ControlWrapperComponent]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9hbmd1bGFyLWdvb2dsZS1jaGFydHMvc3JjL2xpYi9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHckMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFFaEYsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOENBQThDLENBQUM7Ozs7O0FBU3ZGLE1BQU0sT0FBTyxrQkFBa0I7QUFBRyxJQTBDaEMsWUFBb0IsT0FBbUIsRUFBVSxhQUFrQztBQUFJLFFBQW5FLFlBQU8sR0FBUCxPQUFPLENBQVk7QUFBQyxRQUFTLGtCQUFhLEdBQWIsYUFBYSxDQUFxQjtBQUFDLFFBeEJwRjtBQUNGO0FBRUM7QUFBVztBQUNNO0FBQ007QUFHWixXQUZQO0FBQ0wsUUFDUyxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztBQUMxQyxRQUNFO0FBQ0Y7QUFDTTtBQUVBLFdBREQ7QUFDTCxRQUNTLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBbUIsQ0FBQztBQUNyRCxRQU1VLGdCQUFXLEdBQUcsS0FBSyxDQUFDO0FBQzlCLElBQ3dGLENBQUM7QUFDekYsSUFDUyxRQUFRO0FBQ2pCLFFBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO0FBQ3BFLFlBQU0sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQzdCLFlBQU0sSUFB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Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDaGFydEVycm9yRXZlbnQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZXZlbnRzLm1vZGVsJztcbmltcG9ydCB7IFNjcmlwdExvYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zY3JpcHQtbG9hZGVyL3NjcmlwdC1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDb2x1bW4sIFJvdyB9IGZyb20gJy4uL2NoYXJ0LWJhc2UvY2hhcnQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udHJvbFdyYXBwZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb250cm9sLXdyYXBwZXIvY29udHJvbC13cmFwcGVyLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Rhc2hib2FyZCcsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBleHBvcnRBczogJ2Rhc2hib2FyZCcsXG4gIGhvc3Q6IHsgY2xhc3M6ICdkYXNoYm9hcmQnIH1cbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICAvKipcbiAgICogRGF0YSB1c2VkIHRvIGluaXRpYWxpemUgdGhlIHRhYmxlLlxuICAgKlxuICAgKiBUaGlzIG11c3QgYWxzbyBjb250YWluIGFsbCByb2xlcyB0aGF0IGFyZSBzZXQgaW4gdGhlIGBjb2x1bW5zYCBwcm9wZXJ0eS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBkYXRhITogUm93W107XG5cbiAgLyoqXG4gICAqIFRoZSBjb2x1bW5zIHRoZSBgZGF0YWAgY29uc2lzdHMgb2YuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2YgZWFjaCByb3cgaW4gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAqXG4gICAqIElmIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jaGFydC9pbnRlcmFjdGl2ZS9kb2NzL3JvbGVzIHJvbGVzfSBzaG91bGQgYmUgYXBwbGllZCwgdGhleSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoaXMgYXJyYXkgYXMgd2VsbC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBjb2x1bW5zOiBDb2x1bW5bXTtcblxuICAvKipcbiAgICogVGhlIGRhc2hib2FyZCBoYXMgY29tcGxldGVkIGRyYXdpbmcgYW5kIGlzIHJlYWR5IHRvIGFjY2VwdCBjaGFuZ2VzLlxuICAgKlxuICAgKiBUaGUgcmVhZHkgZXZlbnQgd2lsbCBhbHNvIGZpcmU6XG4gICAqIC0gYWZ0ZXIgdGhlIGNvbXBsZXRpb24gb2YgYSBkYXNoYm9hcmQgcmVmcmVzaCB0cmlnZ2VyZWQgYnkgYSB1c2VyIG9yIHByb2dyYW1tYXRpYyBpbnRlcmFjdGlvbiB3aXRoIG9uZSBvZiB0aGUgY29udHJvbHMsXG4gICAqIC0gYWZ0ZXIgcmVkcmF3aW5nIGFueSBjaGFydCBvbiB0aGUgZGFzaGJvYXJkLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyByZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hlbiBhdHRlbXB0aW5nIHRvIHJlbmRlciB0aGUgZGFzaGJvYXJkLlxuICAgKiBPbmUgb3IgbW9yZSBvZiB0aGUgY29udHJvbHMgYW5kIGNoYXJ0cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBkYXNoYm9hcmQgbWF5IGhhdmUgZmFpbGVkIHJlbmRlcmluZy5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBwdWJsaWMgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0RXJyb3JFdmVudD4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKENvbnRyb2xXcmFwcGVyQ29tcG9uZW50KVxuICBwcml2YXRlIGNvbnRyb2xXcmFwcGVyczogUXVlcnlMaXN0PENvbnRyb2xXcmFwcGVyQ29tcG9uZW50PjtcblxuICBwcml2YXRlIGRhc2hib2FyZDogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGFzaGJvYXJkO1xuICBwcml2YXRlIGRhdGFUYWJsZTogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGF0YVRhYmxlO1xuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIGxvYWRlclNlcnZpY2U6IFNjcmlwdExvYWRlclNlcnZpY2UpIHt9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMubG9hZGVyU2VydmljZS5sb2FkQ2hhcnRQYWNrYWdlcygnY29udHJvbHMnKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jcmVhdGVEYXRhVGFibGUoKTtcbiAgICAgIHRoaXMuY3JlYXRlRGFzaGJvYXJkKCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuZGF0YSB8fCBjaGFuZ2VzLmNvbHVtbnMpIHtcbiAgICAgIHRoaXMuY3JlYXRlRGF0YVRhYmxlKCk7XG4gICAgICB0aGlzLmRhc2hib2FyZC5kcmF3KHRoaXMuZGF0YVRhYmxlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURhc2hib2FyZCgpIHtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBoYXBwZW4gaW4gdGhlIGNvbnRyb2wgd3JhcHBlclxuICAgIC8vIEhvd2V2ZXIsIEkgZG9uJ3QgeWV0IGtub3cgaG93IHRvIGRvIHRoaXMgYmVjYXVzZSB0aGVuIGBiaW5kKClgIHdvdWxkIGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAvLyBmb3IgdGhlIHNhbWUgY29udHJvbCBpZiBzb21ldGhpbmcgY2hhbmdlcy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGdvb2dsZSBjaGFydHMgYXMgZmFyIGFzIEkgY2FuIHRlbGxcbiAgICAvLyBmcm9tIHRoZWlyIHNvdXJjZSBjb2RlLlxuICAgIGNvbnN0IGNvbnRyb2xXcmFwcGVyc1JlYWR5JCA9IHRoaXMuY29udHJvbFdyYXBwZXJzLm1hcChjb250cm9sID0+IGNvbnRyb2wud3JhcHBlclJlYWR5JCk7XG4gICAgY29uc3QgY2hhcnRzUmVhZHkkID0gdGhpcy5jb250cm9sV3JhcHBlcnNcbiAgICAgIC5tYXAoY29udHJvbCA9PiBjb250cm9sLmZvcilcbiAgICAgIC5tYXAoY2hhcnRzID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhcnRzKSkge1xuICAgICAgICAgIC8vIENvbWJpbmVMYXRlc3Qgd2FpdHMgZm9yIGFsbCBvYnNlcnZhYmxlc1xuICAgICAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KGNoYXJ0cy5tYXAoY2hhcnQgPT4gY2hhcnQud3JhcHBlclJlYWR5JCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaGFydHMud3JhcHBlclJlYWR5JDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAvLyBXZSBoYXZlIHRvIHdhaXQgZm9yIGFsbCBjaGFydCB3cmFwcGVycyBhbmQgY29udHJvbCB3cmFwcGVycyB0byBiZSBpbml0aWFsaXplZFxuICAgIC8vIGJlZm9yZSB3ZSBjYW4gY29tcG9zZSB0aGVtIHRvZ2V0aGVyIHRvIGNyZWF0ZSB0aGUgZGFzaGJvYXJkXG4gICAgY29tYmluZUxhdGVzdChbLi4uY29udHJvbFdyYXBwZXJzUmVhZHkkLCAuLi5jaGFydHNSZWFkeSRdKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5kYXNoYm9hcmQgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGFzaGJvYXJkKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUJpbmRpbmdzKCk7XG4gICAgICB0aGlzLmRhc2hib2FyZC5kcmF3KHRoaXMuZGF0YVRhYmxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUJpbmRpbmdzKCkge1xuICAgIHRoaXMuY29udHJvbFdyYXBwZXJzLmZvckVhY2goY29udHJvbCA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sLmZvcikpIHtcbiAgICAgICAgY29uc3QgY2hhcnRXcmFwcGVycyA9IGNvbnRyb2wuZm9yLm1hcChjaGFydCA9PiBjaGFydC5jaGFydFdyYXBwZXIpO1xuICAgICAgICB0aGlzLmRhc2hib2FyZC5iaW5kKGNvbnRyb2wuY29udHJvbFdyYXBwZXIsIGNoYXJ0V3JhcHBlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmQuYmluZChjb250cm9sLmNvbnRyb2xXcmFwcGVyLCBjb250cm9sLmZvci5jaGFydFdyYXBwZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEYXRhVGFibGUoKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0Um93SXNEYXRhID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jb2x1bW5zICE9IG51bGwpIHtcbiAgICAgIGZpcnN0Um93SXNEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhVGFibGUgPSBnb29nbGUudmlzdWFsaXphdGlvbi5hcnJheVRvRGF0YVRhYmxlKHRoaXMuZ2V0RGF0YUFzVGFibGUoKSwgZmlyc3RSb3dJc0RhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREYXRhQXNUYWJsZSgpOiAoUm93IHwgQ29sdW1uW10pW10ge1xuICAgIGlmICh0aGlzLmNvbHVtbnMpIHtcbiAgICAgIHJldHVybiBbdGhpcy5jb2x1bW5zLCAuLi50aGlzLmRhdGFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbiAgfVxufVxuIl19