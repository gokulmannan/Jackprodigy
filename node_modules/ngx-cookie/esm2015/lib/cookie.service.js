import { DOCUMENT } from '@angular/common';
import { Inject, Injectable } from '@angular/core';
import { CookieOptionsProvider } from './cookie-options.provider';
import { COOKIE_WRITER } from './tokens';
import { isNil, isPresent, mergeOptions, parseCookieString } from './utils';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './cookie-options.provider';
export class CookieService {
    constructor(document, optionsProvider, cookieWriterService) {
        this.document = document;
        this.optionsProvider = optionsProvider;
        this.cookieWriterService = cookieWriterService;
        this.options = this.optionsProvider.options;
    }
    /**
     * @description
     * Returns if the given cookie key exists or not.
     *
     * @param key Id to use for lookup.
     * @returns true if key exists, otherwise false.
     */
    hasKey(key) {
        const value = this.get(key);
        return isPresent(value);
    }
    /**
     * @description
     * Returns the value of given cookie key.
     *
     * @param key Id to use for lookup.
     * @returns Raw cookie value.
     */
    get(key) {
        var _a;
        return (_a = this.getAll()) === null || _a === void 0 ? void 0 : _a[key];
    }
    /**
     * @description
     * Returns the deserialized value of given cookie key.
     *
     * @param key Id to use for lookup.
     * @returns Deserialized cookie value.
     */
    getObject(key) {
        const value = this.get(key);
        if (isNil(value)) {
            return undefined;
        }
        else if (value === '') {
            return {};
        }
        return JSON.parse(value);
    }
    /**
     * @description
     * Returns a key value object with all the cookies.
     *
     * @returns All cookies
     */
    getAll() {
        const cookieString = this.cookieWriterService.readAllAsString();
        return parseCookieString(cookieString);
    }
    /**
     * @description
     * Sets a value for given cookie key.
     *
     * @param key Id for the `value`.
     * @param value Raw value to be stored.
     * @param options (Optional) Options object.
     */
    put(key, value, options) {
        const opts = mergeOptions(this.options, options);
        this.cookieWriterService.write(key, value, opts);
    }
    /**
     * @description
     * Serializes and sets a value for given cookie key.
     *
     * @param key Id for the `value`.
     * @param value Value to be stored.
     * @param options (Optional) Options object.
     */
    putObject(key, value, options) {
        this.put(key, JSON.stringify(value), options);
    }
    /**
     * @description
     * Remove given cookie.
     *
     * @param key Id of the key-value pair to delete.
     * @param options (Optional) Options object.
     */
    remove(key, options) {
        this.put(key, undefined, options);
    }
    /**
     * @description
     * Remove all cookies.
     */
    removeAll(options) {
        const cookies = this.getAll();
        Object.keys(cookies).forEach(key => this.remove(key, options));
    }
}
CookieService.ɵfac = function CookieService_Factory(t) { return new (t || CookieService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc1.CookieOptionsProvider), ɵngcc0.ɵɵinject(COOKIE_WRITER)); };
CookieService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CookieService, factory: CookieService.ɵfac });
CookieService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: CookieOptionsProvider },
    { type: undefined, decorators: [{ type: Inject, args: [COOKIE_WRITER,] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CookieService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc1.CookieOptionsProvider }, { type: undefined, decorators: [{
                type: Inject,
                args: [COOKIE_WRITER]
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29va2llLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1jb29raWUvc3JjL2xpYi9jb29raWUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHbEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUN6QyxPQUFPLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxTQUFTLENBQUM7OztBQUc1RSxNQUFNLE9BQU8sYUFBYTtBQUFHLElBSTNCLFlBQXNDLFFBQWEsRUFDL0IsZUFBc0MsRUFDZixtQkFBeUM7QUFDdEYsUUFId0MsYUFBUSxHQUFSLFFBQVEsQ0FBSztBQUFDLFFBQ2hDLG9CQUFlLEdBQWYsZUFBZSxDQUF1QjtBQUFDLFFBQ2hCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBc0I7QUFBQyxRQUNuRixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDO0FBQ2hELElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FEQztBQUNMLElBQUUsTUFBTSxDQUFDLEdBQVc7QUFBSSxRQUNwQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLFFBQUksT0FBTyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUIsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBQ0U7QUFFSixPQURDO0FBQ0wsSUFBRSxHQUFHLENBQUMsR0FBVztBQUFJO0FBQ2IsUUFBSixhQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsMENBQUcsR0FBRyxFQUFFO0FBQ2hDLElBQUUsQ0FBQztBQUNILElBQ0U7QUFDRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FEQztBQUNMLElBQUUsU0FBUyxDQUFDLEdBQVc7QUFBSSxRQUN2QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLFFBQUksSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDdEIsWUFBTSxPQUFPLFNBQVMsQ0FBQztBQUN2QixTQUFLO0FBQUMsYUFBSyxJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7QUFDN0IsWUFBTSxPQUFPLEVBQUUsQ0FBQztBQUNoQixTQUFLO0FBQ0wsUUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0IsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FERztBQUNMLElBQUUsTUFBTTtBQUFLLFFBQ1QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQ3BFLFFBQUksT0FBTyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUMzQyxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBRUosT0FERDtBQUNMLElBQUUsR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUF5QixFQUFFLE9BQXVCO0FBQUksUUFDckUsTUFBTSxJQUFJLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDckQsUUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDckQsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBQ0U7QUFDRTtBQUVKLE9BREQ7QUFDTCxJQUFFLFNBQVMsQ0FBQyxHQUFXLEVBQUUsS0FBYSxFQUFFLE9BQXVCO0FBQUksUUFDL0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNsRCxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0U7QUFDRTtBQUVKLE9BREM7QUFDTCxJQUFFLE1BQU0sQ0FBQyxHQUFXLEVBQUUsT0FBdUI7QUFBSSxRQUM3QyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDdEMsSUFBRSxDQUFDO0FBQ0gsSUFDRTtBQUNGO0FBQ0U7QUFDRSxPQUFDO0FBQ0wsSUFBRSxTQUFTLENBQUMsT0FBdUI7QUFBSSxRQUNuQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbEMsUUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDbkUsSUFBRSxDQUFDO0FBQ0g7eUNBMUdDLFVBQVU7dUdBQ1Q7QUFBQztBQUF1Qyw0Q0FJM0IsTUFBTSxTQUFDLFFBQVE7QUFBUyxZQVg5QixxQkFBcUI7QUFBSSw0Q0FhbkIsTUFBTSxTQUFDLGFBQWE7QUFBUTs7Ozs7Ozs7O2tDQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvb2tpZU9wdGlvbnNQcm92aWRlciB9IGZyb20gJy4vY29va2llLW9wdGlvbnMucHJvdmlkZXInO1xuXG5pbXBvcnQgeyBDb29raWVEaWN0LCBDb29raWVPcHRpb25zLCBJQ29va2llU2VydmljZSwgSUNvb2tpZVdyaXRlclNlcnZpY2UgfSBmcm9tICcuL2Nvb2tpZS5tb2RlbCc7XG5pbXBvcnQgeyBDT09LSUVfV1JJVEVSIH0gZnJvbSAnLi90b2tlbnMnO1xuaW1wb3J0IHsgaXNOaWwsIGlzUHJlc2VudCwgbWVyZ2VPcHRpb25zLCBwYXJzZUNvb2tpZVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29va2llU2VydmljZSBpbXBsZW1lbnRzIElDb29raWVTZXJ2aWNlIHtcblxuICBwcm90ZWN0ZWQgb3B0aW9uczogQ29va2llT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgICAgICAgICAgIHByaXZhdGUgb3B0aW9uc1Byb3ZpZGVyOiBDb29raWVPcHRpb25zUHJvdmlkZXIsXG4gICAgICAgICAgICAgIEBJbmplY3QoQ09PS0lFX1dSSVRFUikgcHJpdmF0ZSBjb29raWVXcml0ZXJTZXJ2aWNlOiBJQ29va2llV3JpdGVyU2VydmljZSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9uc1Byb3ZpZGVyLm9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgaWYgdGhlIGdpdmVuIGNvb2tpZSBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIGtleSBJZCB0byB1c2UgZm9yIGxvb2t1cC5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBrZXkgZXhpc3RzLCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBoYXNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGlzUHJlc2VudCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgdG8gdXNlIGZvciBsb29rdXAuXG4gICAqIEByZXR1cm5zIFJhdyBjb29raWUgdmFsdWUuXG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldEFsbCgpPy5ba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIG9mIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgdG8gdXNlIGZvciBsb29rdXAuXG4gICAqIEByZXR1cm5zIERlc2VyaWFsaXplZCBjb29raWUgdmFsdWUuXG4gICAqL1xuICBnZXRPYmplY3Qoa2V5OiBzdHJpbmcpOiBvYmplY3QgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyBhIGtleSB2YWx1ZSBvYmplY3Qgd2l0aCBhbGwgdGhlIGNvb2tpZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEFsbCBjb29raWVzXG4gICAqL1xuICBnZXRBbGwoKTogQ29va2llRGljdCB7XG4gICAgY29uc3QgY29va2llU3RyaW5nID0gdGhpcy5jb29raWVXcml0ZXJTZXJ2aWNlLnJlYWRBbGxBc1N0cmluZygpO1xuICAgIHJldHVybiBwYXJzZUNvb2tpZVN0cmluZyhjb29raWVTdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIGEgdmFsdWUgZm9yIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgZm9yIHRoZSBgdmFsdWVgLlxuICAgKiBAcGFyYW0gdmFsdWUgUmF3IHZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgKE9wdGlvbmFsKSBPcHRpb25zIG9iamVjdC5cbiAgICovXG4gIHB1dChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCwgb3B0aW9ucz86IENvb2tpZU9wdGlvbnMpOiB2b2lkIHtcbiAgICBjb25zdCBvcHRzID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jb29raWVXcml0ZXJTZXJ2aWNlLndyaXRlKGtleSwgdmFsdWUsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXJpYWxpemVzIGFuZCBzZXRzIGEgdmFsdWUgZm9yIGdpdmVuIGNvb2tpZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgSWQgZm9yIHRoZSBgdmFsdWVgLlxuICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAoT3B0aW9uYWwpIE9wdGlvbnMgb2JqZWN0LlxuICAgKi9cbiAgcHV0T2JqZWN0KGtleTogc3RyaW5nLCB2YWx1ZTogb2JqZWN0LCBvcHRpb25zPzogQ29va2llT3B0aW9ucyk6IHZvaWQge1xuICAgIHRoaXMucHV0KGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVtb3ZlIGdpdmVuIGNvb2tpZS5cbiAgICpcbiAgICogQHBhcmFtIGtleSBJZCBvZiB0aGUga2V5LXZhbHVlIHBhaXIgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAoT3B0aW9uYWwpIE9wdGlvbnMgb2JqZWN0LlxuICAgKi9cbiAgcmVtb3ZlKGtleTogc3RyaW5nLCBvcHRpb25zPzogQ29va2llT3B0aW9ucyk6IHZvaWQge1xuICAgIHRoaXMucHV0KGtleSwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVtb3ZlIGFsbCBjb29raWVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsKG9wdGlvbnM/OiBDb29raWVPcHRpb25zKTogdm9pZCB7XG4gICAgY29uc3QgY29va2llcyA9IHRoaXMuZ2V0QWxsKCk7XG4gICAgT2JqZWN0LmtleXMoY29va2llcykuZm9yRWFjaChrZXkgPT4gdGhpcy5yZW1vdmUoa2V5LCBvcHRpb25zKSk7XG4gIH1cblxufVxuIl19